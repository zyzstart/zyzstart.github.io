<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Netty（下） | Michael的小木屋</title><meta name="keywords" content="play hard work hard"><meta name="author" content="Michael"><meta name="copyright" content="Michael"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="IO、网络编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty（下）">
<meta property="og:url" content="http://example.com/2023/10/17/Netty2/index.html">
<meta property="og:site_name" content="Michael的小木屋">
<meta property="og:description" content="IO、网络编程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http:///p2.qhimg.com/t010ad2c94c7a13a383.jpg">
<meta property="article:published_time" content="2023-10-16T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-12T16:30:29.330Z">
<meta property="article:author" content="Michael">
<meta property="article:tag" content="play hard work hard">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:///p2.qhimg.com/t010ad2c94c7a13a383.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/10/17/Netty2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Netty（下）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-13 00:30:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http:///p2.qhimg.com/t010ad2c94c7a13a383.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Michael的小木屋</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Netty（下）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-16T16:00:00.000Z" title="发表于 2023-10-17 00:00:00">2023-10-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-12T16:30:29.330Z" title="更新于 2024-04-13 00:30:29">2024-04-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Netty（下）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="Netty应用开发"><a href="#Netty应用开发" class="headerlink" title="Netty应用开发"></a>Netty应用开发</h3><hr>
<h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h4><h5 id="1-1-什么是Netty"><a href="#1-1-什么是Netty" class="headerlink" title="1.1 什么是Netty"></a>1.1 什么是Netty</h5><blockquote>
<p><a target="_blank" rel="noopener" href="https://netty.io/">https://netty.io/</a></p>
<p>Netty is <em>an asynchronous event-driven network application framework</em><br>for rapid development of maintainable high performance protocol servers &amp; clients.</p>
<p>Netty是一个异步事件驱动的网络应用框架。<br>用于快速开发可维护的高性能协议服务器和客户端。</p>
<p>Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server.</p>
<p>‘Quick and easy’ doesn’t mean that a resulting application will suffer from a maintainability or a performance issue. Netty has been designed carefully with the experiences earned from the implementation of a lot of protocols such as FTP, SMTP, HTTP, and various binary and text-based legacy protocols. As a result, Netty has succeeded to find a way to achieve ease of development, performance, stability, and flexibility without a compromise.</p>
<p>Netty是一个NIO客户服务器框架，它能够快速和容易地开发网络应用，如协议服务器和客户端。它大大简化和精简了网络编程，如TCP和UDP套接字服务器。</p>
<p>快速和简单 “并不意味着开发出来的应用程序会出现可维护性或性能问题。Netty的设计是经过精心设计的，其经验来自于许多协议的实施，如FTP、SMTP、HTTP以及各种基于二进制和文本的遗留协议。因此，Netty成功地找到了一种方法来实现开发的简易性、性能、稳定性和灵活性，而没有任何妥协。</p>
</blockquote>
<h5 id="1-2为什么需要使用Netty"><a href="#1-2为什么需要使用Netty" class="headerlink" title="1.2为什么需要使用Netty"></a>1.2为什么需要使用Netty</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> Netty是完成网络通信的框架，底层封装了NIO</span><br><span class="line"><span class="bullet">2.</span> NIO存在很多问题</span><br><span class="line">   API 复杂难用，尤其是 Buffer 的指针切来切去的 [ByteBuf]</span><br><span class="line">   需要掌握丰富的知识，比如多线程和网络编程</span><br><span class="line">   可靠性无法保证，断线重连、半包粘包、网络拥塞统统需要自己考虑</span><br><span class="line">   空轮询 bug，CPU 又 100% </span><br></pre></td></tr></table></figure>

<h5 id="1-3-Netty的发展历程"><a href="#1-3-Netty的发展历程" class="headerlink" title="1.3 Netty的发展历程"></a>1.3 Netty的发展历程</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> Trustin Lee 2004年开发了Netty，成功入职了Arreo通信公司</span><br><span class="line"><span class="bullet">2.</span> 2008年，Trustin Lee，加入JBoss，发布了Netty3</span><br><span class="line"><span class="bullet">3.</span> 2012年，Trustin Lee，单干，发布了Netty4</span><br><span class="line"><span class="bullet">4.</span> 2013年，发布了Netty5。 引入JDK的新特性，比如 ForkJoinPool等</span><br><span class="line">   使用 ForkJoinPool 提升了复杂性</span><br><span class="line">   没有带来明显的性能提升</span><br><span class="line">   同时维护太多分支太耗费精力</span><br></pre></td></tr></table></figure>

<h5 id="1-4-谁在用Netty"><a href="#1-4-谁在用Netty" class="headerlink" title="1.4 谁在用Netty"></a>1.4 谁在用Netty</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 框架，gRPC、Dubbo、Spring WebFlux、Spring Cloud Gateway</span><br><span class="line"><span class="bullet">2.</span> 大数据，Spark、Hadoop、Flink</span><br><span class="line"><span class="bullet">3.</span> 消息队列，RocketMQ、ActiveMQ</span><br><span class="line"><span class="bullet">4.</span> 搜索引擎，Elasticsearch</span><br><span class="line"><span class="bullet">5.</span> 分布式协调器，Zookeeper</span><br><span class="line"><span class="bullet">6.</span> 数据库，Cassandra、Neo4j</span><br><span class="line"><span class="bullet">7.</span> 负载均衡，Ribbon</span><br></pre></td></tr></table></figure>

<h4 id="Netty的第一个应用"><a href="#Netty的第一个应用" class="headerlink" title="Netty的第一个应用"></a>Netty的第一个应用</h4><h5 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.45.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-第一个程序分析-NIO"><a href="#2-第一个程序分析-NIO" class="headerlink" title="2. 第一个程序分析 [NIO]"></a>2. 第一个程序分析 [NIO]</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyNettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line">        serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建了一组线程 通过死循环 监控状态 accept read write</span></span><br><span class="line">        serverBootstrap.group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ServerSocketChannel  SocketChannel</span></span><br><span class="line">        serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 channel 接通 监控 accept rw 处理 通过流水线 用handler进行处理 。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">//ByteBuf 字节---&gt;字符</span></span><br><span class="line">                <span class="comment">//ch.pipeline().addLast(new StringDecoder());</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> ((ByteBuf) msg).toString(Charset.defaultCharset());</span><br><span class="line">                        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        serverBootstrap.bind(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyNettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line"></span><br><span class="line">        bootstrap.channel(NioSocketChannel.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为什么client 引入事件 循环 组</span></span><br><span class="line">        <span class="comment">// client Netty 做多线程 异步</span></span><br><span class="line">        <span class="comment">// 连接服务端 一个线程</span></span><br><span class="line">        <span class="comment">// 通信 做成一个线程</span></span><br><span class="line">        <span class="comment">// 异步处理  连接 ---&gt;</span></span><br><span class="line">        <span class="comment">//          IO操作</span></span><br><span class="line">        bootstrap.group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>());</span><br><span class="line"></span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">connect</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8000</span>));</span><br><span class="line">        connect.sync();</span><br><span class="line">        <span class="comment">//创建了新的线程 进行写操作</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connect.channel();</span><br><span class="line">        channel.writeAndFlush(<span class="string">&quot;hello suns&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 事件（Accept READ WRITE） 循环(死循环)</span><br><span class="line"><span class="bullet">2.</span> 曾经讲过的worker </span><br><span class="line"><span class="bullet">   1.</span> 独立线程</span><br><span class="line"><span class="bullet">   2.</span> 通过死循环 监控 状态 进行操作 --》 run</span><br><span class="line"><span class="code">      while(true)&#123;</span></span><br><span class="line"><span class="code">         selector.select</span></span><br><span class="line"><span class="code">         </span></span><br><span class="line"><span class="code">         SelectionKeys 遍历</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line"><span class="code">   3. Selector</span></span><br><span class="line"><span class="code">   </span></span><br><span class="line"><span class="code">EventLoop     worker 线程 select ---&gt; READ WRITE </span></span><br><span class="line"><span class="code">              boss   线程 select ---&gt; Accept</span></span><br><span class="line"><span class="code">              </span></span><br><span class="line"><span class="code">开发中 如何过的EventLoop </span></span><br><span class="line"><span class="code">1. 不会通过构造方法 让程序员创建。</span></span><br><span class="line"><span class="code">2. 通过EventLoopGroup创建</span></span><br></pre></td></tr></table></figure>

<h5 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 编程的过程中，开放的编程接口 EventLoopGroup</span><br><span class="line"><span class="bullet">2.</span> EventLoopGroup 创建EventLoop(一个线程) 多个EventLoop(多个线程)</span><br><span class="line"><span class="code">                  管理EventLoop  </span></span><br><span class="line"><span class="code">                  </span></span><br><span class="line"><span class="code">                  EventLoopGroup EventLoop的工厂</span></span><br></pre></td></tr></table></figure>

<h5 id="NioEventLoop和DefaultEventLoop区别"><a href="#NioEventLoop和DefaultEventLoop区别" class="headerlink" title="NioEventLoop和DefaultEventLoop区别"></a>NioEventLoop和DefaultEventLoop区别</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> NioEventLoop 是一个线程  IO Write Read 事件监控</span><br><span class="line"><span class="bullet">2.</span> DefaultEventLooop 就是一个普通的线程，内容工作可以由程序员决定，他不做 IO监控 读写的处理.</span><br><span class="line"></span><br><span class="line">注意：后续再Netty进行多线程开发，推荐大家优先考虑DefaultEventLoop --&gt;普通线程。</span><br></pre></td></tr></table></figure>

<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> EventLoop是会绑定channel，EventLoop可以支持多个channel访问的。</span><br><span class="line"><span class="bullet">2.</span> 服务端 进行EventLoop的分工 ---&gt;  主从Reactor模式（NIO,Netty...)</span><br><span class="line"><span class="bullet">3.</span> DefaultEventLoop，辅助NIOEventLoop完成 普通业务操作。</span><br></pre></td></tr></table></figure>

<h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">处理过程中 </span><br><span class="line"><span class="bullet">1.</span> 阻塞 主线程 完成异步操作的配合。</span><br><span class="line">   future.sync();</span><br><span class="line"><span class="bullet">2.</span> 异步处理 （新线程 异步线程完成的）</span><br><span class="line"><span class="code">    future.addListener(new ChannelFutureListener() &#123;</span></span><br><span class="line"><span class="code">      @Override</span></span><br><span class="line"><span class="code">      public void operationComplete(ChannelFuture future) throws Exception &#123;</span></span><br><span class="line"><span class="code">      log1.debug(&quot; add Listerner .....&quot;);</span></span><br><span class="line"><span class="code">      Channel channel = future.channel();</span></span><br><span class="line"><span class="code">      channel.writeAndFlush(&quot;hello suns&quot;);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    &#125;);</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">只要是异步的操作 只能通过上述的2种方式的一种处理。</span></span><br><span class="line"><span class="code">在Netty只要涉及到 网络 IO的相关操作 那么Netty都会涉及异步处理。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">.connect() netty 异步   </span><br><span class="line">.writeAndFlush   异步</span><br><span class="line">.close()         异步 </span><br><span class="line"></span><br><span class="line">Netty为什么 要把 网络 IO的相关操作 做成异步？</span><br><span class="line">异步的好处？</span><br><span class="line">1.提高系统的吞吐量。。。</span><br><span class="line">2.效率上的提高 绝不是 1+1=2</span><br><span class="line"><span class="code">                   1+1 = 1.5</span></span><br></pre></td></tr></table></figure>

<h5 id="Netty中异步设计-（内部原理）"><a href="#Netty中异步设计-（内部原理）" class="headerlink" title="Netty中异步设计 （内部原理）"></a>Netty中异步设计 （内部原理）</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JDK   Future</span><br><span class="line">Netty Future</span><br><span class="line">Netty Promise</span><br></pre></td></tr></table></figure>

<h5 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> JDK ServerSocketChannel  SocketChannel</span><br><span class="line"><span class="bullet">2.</span> Netty原有JDK中channel进行 统一的封装。</span><br><span class="line"><span class="bullet">   1.</span> 统一channel的编程模型，通过他的封装 不在让客户区分SocketChannel ServerSocketChannel</span><br><span class="line"><span class="bullet">   2.</span> Netty 一旦封装了Channel，更好的和Netty框架结合起来。 I/0  pipeline ,配置 Channel TCP Socket缓冲区 滑动窗口的大小。。 </span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> Netty封装Channel 提供哪些API (方法)</span><br><span class="line">   channel.writeAndFlush(&quot;xiaohei&quot;); </span><br><span class="line"><span class="code">          .write</span></span><br><span class="line"><span class="code">          </span></span><br><span class="line"><span class="code">   writeAndFlush 写出数据后 刷新缓冲区 ---》 写出去了</span></span><br><span class="line"><span class="code">   write不会立即发出去的，存在缓冲区中，手工.flush.</span></span><br><span class="line"><span class="code">   </span></span><br><span class="line"><span class="code">   .close() 顾名思义 作用 channel.close() ---&gt; Socket </span></span><br><span class="line"><span class="code">    ChannelFuture close = channel.close();//异步化操作 启动一个新的线程</span></span><br><span class="line"><span class="code">         //其他资源的释放，其他事，close()方法执行完之后，运行后面这些代码</span></span><br><span class="line"><span class="code">        //main主线程完成</span></span><br><span class="line"><span class="code">        //close.sync();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    close.addListener(new ChannelFutureListener() &#123;</span></span><br><span class="line"><span class="code">      @Override</span></span><br><span class="line"><span class="code">      public void operationComplete(ChannelFuture future) throws Exception &#123;</span></span><br><span class="line"><span class="code">      log.debug(&quot;channel.close()执行完后，操作后续的一些工作...&quot;);//不行</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line"><span class="code">    &#125;);</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    eventLoopGroup.shutdownGracefully();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">2.</span> 如何封装的Channel(源码)</span><br></pre></td></tr></table></figure>

<h5 id="Handler-重要-程序员编程"><a href="#Handler-重要-程序员编程" class="headerlink" title="Handler[重要 程序员编程]"></a>Handler[重要 程序员编程]</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> Handler作用，用于处理接受 或者发送前的数据。程序员使用netty最重要的战斗场地</span><br><span class="line"><span class="bullet">2.</span> 通过Pipeline 把多个handler有机整合成了一个整体。</span><br><span class="line">   读取数据   ChannleInboundHandler  子类</span><br><span class="line">   写出数据   ChannelOutboundHandler 子类 </span><br><span class="line"><span class="bullet">3.</span> Pipleline中 执行Handler有固定顺序 （类似一个栈）双向链表</span><br><span class="line"><span class="bullet">4.</span> Handler传递数据 </span><br><span class="line"><span class="code">     super.channelRead(ctx, msg);</span></span><br><span class="line"><span class="code">     最后一个Handler不需要传递数据时，那么上述方法 也就无需调用。</span></span><br><span class="line"><span class="code">     底层 ctx.fireChannelRead(s);</span></span><br><span class="line"><span class="code">5. 最后一个handler如果不需要传递数据了</span></span><br><span class="line"><span class="code">   无需调用 </span></span><br><span class="line"><span class="code">    super.channelRead(ctx, msg);</span></span><br><span class="line"><span class="code">    ctx.fireChannelRead(s);</span></span><br><span class="line"><span class="code">6. Head Tail 2个默认的Handler在Pipeline</span></span><br><span class="line"><span class="code">   head --&gt; handler1 ---&gt; StingDecoder ---&gt; handler2 ---&gt; handler3 --&gt; tail </span></span><br><span class="line"><span class="code">  </span></span><br><span class="line"><span class="code">7. OutboundHandler 特性 编码顺序 和 运行顺序 相反 </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">8.</span> 同一种Handler的编码顺序 和 运行顺序 相关 。 h1 h2 h3</span><br><span class="line"><span class="code">                                          h1 h3 h2    </span></span><br><span class="line"><span class="code">                                          </span></span><br><span class="line"><span class="code">   不同种的Handler，顺序有所不同，不会影响运行效果。</span></span><br><span class="line"><span class="code">   </span></span><br><span class="line"><span class="code">9. 注意</span></span><br><span class="line"><span class="code">   ch.writeAndFlush(&quot;hello  suns&quot;);</span></span><br><span class="line"><span class="code">   全局的查找输出OutboundHandler 依次运行 </span></span><br><span class="line"><span class="code">   ctx.writeAndFlush(&quot;hello xiaojr&quot;);</span></span><br><span class="line"><span class="code">   从当前Handler，往前查找，没有输出的OutboundHandler。</span></span><br><span class="line"><span class="code">   </span></span><br><span class="line"><span class="code">10. 方便测试Handller</span></span><br><span class="line"><span class="code">    EmbeddedChannel</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240413003020433.png" alt="image-20240413003020433"></p>
<h5 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 类似NIO ByteBuffer --- Netty网络通信的过程中，底层数据存储ByteBuf。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> ByteBuf --&gt; ByteBuffer封装</span><br><span class="line"><span class="bullet">   1.</span> 自动扩容</span><br><span class="line"><span class="bullet">   2.</span> 读写的指针，方便操作。  ByteBuffer没有读写指针的。读模式.flip 写模式 clear compact() </span><br><span class="line"><span class="bullet">   3.</span> 内存的池化。（连接池，线程池）</span><br><span class="line"><span class="bullet">   4.</span> 0copy相关内容。netty 0copy 尽可能少占用内存。</span><br></pre></td></tr></table></figure>

<h5 id="ByteBuf的基础使用"><a href="#ByteBuf的基础使用" class="headerlink" title="ByteBuf的基础使用"></a>ByteBuf的基础使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="comment">//如何获得ByteBuf 1. 支持自动扩容 2. 制定byteBuf初始化大小 3.256 3. 最大值 Integer.max,在构造方法中指定最大值</span></span><br><span class="line">   <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>自动扩容 什么规律？ 扩充到最大的ByteBuf的值</span><br><span class="line">  <span class="number">4</span>的n次方 ---&gt; <span class="number">4</span> 二次方 <span class="number">16</span>  <span class="number">4</span> 三次方 <span class="number">64</span> ---&gt; 原有数据*<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h5 id="ByteBuf与内存关系"><a href="#ByteBuf与内存关系" class="headerlink" title="ByteBuf与内存关系"></a>ByteBuf与内存关系</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 堆内存</span><br><span class="line"><span class="code">      创建和销毁 代价小。读写效率（低），GC压力大</span></span><br><span class="line"><span class="code">2. 直接内存</span></span><br><span class="line"><span class="code">      创建和销毁 代价大。GC压力小。</span></span><br><span class="line"><span class="code">3. 引入了ByteBuf池化思想</span></span><br><span class="line"><span class="code">   1. 站在调用者提高创建的效率。</span></span><br><span class="line"><span class="code">   2. 合理的使用了资源  —&gt;  jemalloc</span></span><br><span class="line"><span class="code">   3. 减少内存溢出的可能 （内存不够用，内存使用过多）</span></span><br><span class="line"><span class="code">   </span></span><br><span class="line"><span class="code">4. Netty池化默认开启的</span></span><br><span class="line"><span class="code">   4.1以后 ByteBuf池化 </span></span><br><span class="line"><span class="code">   4.1以前 关闭</span></span><br><span class="line"><span class="code">   -Dio.netty.allocator.type=pooled unpooled</span></span><br></pre></td></tr></table></figure>

<h5 id="ByteBuf内存结构"><a href="#ByteBuf内存结构" class="headerlink" title="ByteBuf内存结构"></a>ByteBuf内存结构</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> ByteBuffer 读写模式切换 。 clear() compact()   flip()</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 读写指针 </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zyzstart/picgodemo/img/image-20240413000023994.png" alt="image-20240413000023994"></p>
<h5 id="ByteBuf内存释放"><a href="#ByteBuf内存释放" class="headerlink" title="ByteBuf内存释放"></a>ByteBuf内存释放</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 是不是回收，清空？销毁？</span><br><span class="line">   不是，如果ByteBuf池化的，内存释放。---》放回byteBuf的池子。</span><br><span class="line">   及使不是ByteBuf池化的 释放，不一定立即销毁。堆内存，垃圾回收。</span><br><span class="line"><span class="bullet">2.</span> Netty在处理内存释放时，因为内存释放情况种类繁多，所以netty对于编程人员来讲，设计了统一的内存释放接口。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> RefrenceCounted(引用计数器)--》</span><br><span class="line">   ByteBuf</span><br><span class="line"></span><br><span class="line"><span class="code">    创建一个ByteBuf  —&gt; 1</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    ByteBuf —&gt; retain +1</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    ByteBuf —&gt; release -1 …0</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code"> 4. ByteBuf什么时候需要释放？</span></span><br><span class="line"><span class="code">    1. ByteBuf一定只能应用在pipeline中，在handler中进行释放数据最为理想且稳妥。</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    2. tailContext 会对读到的数据进行ByteBuf释放。</span></span><br><span class="line"><span class="code">       headContext 会对写的数据进行ByteBuf的释放。</span></span><br><span class="line"><span class="code">       </span></span><br><span class="line"><span class="code">       最后一次程序员在handler中使用ByteBuf时候，做ByteBuf释放。</span></span><br></pre></td></tr></table></figure>

<h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分片 slice</span><br></pre></td></tr></table></figure>

<h5 id="半包粘包-（黏包）"><a href="#半包粘包-（黏包）" class="headerlink" title="半包粘包 （黏包）"></a>半包粘包 （黏包）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 半包粘包</span><br><span class="line">   本质 接受数据时，数据有可能接受不完整，也可能接受过多。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zyzstart/picgodemo/img/image-20240413000114439.png" alt="image-20240413000114439"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 网络通信过程中，什么情况可以导致接受数据不完整或者过多？</span><br><span class="line"><span class="bullet">   1.</span> ByteBuf</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zyzstart/picgodemo/img/image-20240413000101645.png" alt="image-20240413000101645"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> Netty通信过程中，用于网络通信的ByteBuf是Netty创建。</span><br><span class="line"><span class="bullet">   1.</span> 如何获得？</span><br><span class="line"><span class="code">      Handler 第一个非head得inboundhandler 获得 参数 就是Netty读取数据后，封装ByteBuf。</span></span><br><span class="line"><span class="code">   2. Netty创建的ByteBuf默认大小多大？</span></span><br><span class="line"><span class="code">      接受数据所创建的ByteBuf 大小默认 1024  </span></span><br></pre></td></tr></table></figure>

<h5 id="Netty半包粘包的解决方式-思路分析"><a href="#Netty半包粘包的解决方式-思路分析" class="headerlink" title="Netty半包粘包的解决方式 思路分析"></a>Netty半包粘包的解决方式 思路分析</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> ByteBuf---&gt;handler---&gt;第一个非head得handler</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> decoder|encoder  ---&gt; 原始字节 Byte ---&gt; Message[半包 粘包 都解决完成了]</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> ByteToMessageDecoder 完成 ByteBuf ---&gt; Message(完整的消息 不应该半包粘包)</span><br><span class="line"></span><br><span class="line">解决半包粘包的方式 </span><br><span class="line"><span class="bullet">1.</span> FixedLengthFrameDecoder 固定长度的解码器 </span><br><span class="line">   解决的问题是 固定长度消息的 半包粘包问题。  </span><br><span class="line">   新问题 10</span><br><span class="line">   client ---&gt; abc<span class="strong">____</span><span class="strong">____</span><span class="emphasis">_</span></span><br><span class="line"><span class="emphasis">   </span></span><br><span class="line"><span class="emphasis">   不好的地方 占用空间 </span></span><br><span class="line"><span class="emphasis">   </span></span><br><span class="line"><span class="emphasis">2. LineBasedFrameDecoder  要求你每一个完成的消息必须有个分割符 \n \r\n</span></span><br><span class="line"><span class="emphasis">   DelimiterBasedFrameDecoder 自定义分割符</span></span><br><span class="line"><span class="emphasis">   </span></span><br><span class="line"><span class="emphasis">3. LengthFieldBasedFrameDecoder</span></span><br><span class="line"><span class="emphasis">   lengthFieldOffset  从第几个字节开始找 length 位</span></span><br><span class="line"><span class="emphasis">   lengthFieldLength length位的长度</span></span><br><span class="line"><span class="emphasis">   lengthAdjustment length位后面第几个字节是内容</span></span><br><span class="line"><span class="emphasis">   initailByteToStrip  去头 </span></span><br></pre></td></tr></table></figure>

<h4 id="编解码器-（Codec）"><a href="#编解码器-（Codec）" class="headerlink" title="编解码器 （Codec）"></a>编解码器 （Codec）</h4><h5 id="1-什么是编解码"><a href="#1-什么是编解码" class="headerlink" title="1. 什么是编解码"></a>1. 什么是编解码</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 编码  Java对象 ---》 二进制 （Byte)</span><br><span class="line"><span class="bullet">2.</span> 解码  二进制   ---》 Java对象 </span><br><span class="line"></span><br><span class="line">广义编解码 （codec) 2部分</span><br><span class="line"><span class="bullet">1.</span> encode  Java对象 ---》 二进制 （Byte)</span><br><span class="line"><span class="bullet">2.</span> decode  二进制   ---》 Java对象 </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zyzstart/picgodemo/img/image-20240413000148565.png" alt="image-20240413000148565"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Netty中编解码的体现 </span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line">   1. encode  Java对象 ---》 二进制 （Byte)</span><br><span class="line"><span class="bullet">   2.</span> decode  二进制   ---》 Java对象 </span><br><span class="line">   </span><br><span class="line"><span class="bullet">2.</span> Netty中编解码工作 谁做的呢？</span><br><span class="line">   Handler --&gt; ChannelHandler </span><br><span class="line">   </span><br><span class="line">   ByteToMessageCodec </span><br><span class="line">   ByteToMessageDecoder  --- 实际开发解码器 就作为这个类型的子类 </span><br><span class="line">   MessageToByteEncoder  --- 实际开发编码器 就作为这个类型的子类 </span><br><span class="line">  </span><br><span class="line"><span class="bullet">3.</span> 编解码器 在使用过程中 2部分核心内容</span><br><span class="line"><span class="bullet">   1.</span> 序列化协议（编码格式）（传输数据的格式）</span><br><span class="line"><span class="bullet">      1.</span> java序列化 和 反序列化 </span><br><span class="line"><span class="bullet">         1.</span> 类 implements Seriliazable接口 （标识性接口）接口里面没有方法 实现的 Spring ThrowsAdvice</span><br><span class="line"><span class="bullet">         2.</span> ObjectOutputStream ---&gt; Java 转换成 二进制的内容 ---&gt; 文件|通过网络进行传输 </span><br><span class="line"><span class="code">            ObjectInputStream  ---&gt; 二进制的内容 转换成 Java </span></span><br><span class="line"><span class="code">         3. serialVersionUID private static final long </span></span><br><span class="line"><span class="code">            1. serialVersionUID --&gt; 如果不显示创建 java在序列化的过程中会不会创建？默认创建的 hashCode </span></span><br><span class="line"><span class="code">         </span></span><br><span class="line"><span class="code">         问题：</span></span><br><span class="line"><span class="code">            1. 无法跨语言的</span></span><br><span class="line"><span class="code">            2. 可读性差 ---&gt; 二进制</span></span><br><span class="line"><span class="code">            3. java序列化后的数据大小 大 ---》 ByteBuffer 5倍 传输效率 低</span></span><br><span class="line"><span class="code">            4. java序列化操作的时间 ---》ByteBuffer 5倍</span></span><br><span class="line"><span class="code">   </span></span><br><span class="line"><span class="code">      2. XML</span></span><br><span class="line"><span class="code">            c   --------------------------------------------  s</span></span><br><span class="line"><span class="code">            &lt;user&gt;</span></span><br><span class="line"><span class="code">               &lt;id&gt;1&lt;/id&gt;</span></span><br><span class="line"><span class="code">               &lt;name&gt;sunshuai&lt;/name&gt;</span></span><br><span class="line"><span class="code">            &lt;/user&gt;</span></span><br><span class="line"><span class="code">            </span></span><br><span class="line"><span class="code">      3. JSON</span></span><br><span class="line"><span class="code">           可读性好 &#123;&quot;name&quot;:&quot;sunshuai&quot;,&quot;age&quot;:10&#125;,数据量 &gt; 二进制的内容。 HTTP协议 + JSON -&gt;SpringCloud</span></span><br><span class="line"><span class="code">           </span></span><br><span class="line"><span class="code">      4. msgpack</span></span><br><span class="line"><span class="code">          类似于JSON,二进制传输。效率高 数据体量小 ---》支持多语言的  【bson ---&gt; mongodb】4倍与protobuf</span></span><br><span class="line"><span class="code">          </span></span><br><span class="line"><span class="code">      5. protobuf google</span></span><br><span class="line"><span class="code">         二进制 支持多种编程语言 -&gt; 自己的编译器，把数据格式编译成中间语言 ---&gt; go python.. 更小 更快 可读性差。</span></span><br><span class="line"><span class="code">         Hadoop  </span></span><br><span class="line"><span class="code">       </span></span><br><span class="line"><span class="code">   2. 具体的编解码器 </span></span><br><span class="line"><span class="code">       ByteToMessageDecoder  --- 实际开发解码器 就作为这个类型的子类 </span></span><br><span class="line"><span class="code">       MessageToByteEncoder  --- 实际开发编码器 就作为这个类型的子类 </span></span><br></pre></td></tr></table></figure>

<h5 id="Netty常见的编解码器"><a href="#Netty常见的编解码器" class="headerlink" title="Netty常见的编解码器"></a>Netty常见的编解码器</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> StringDecoder StringEncoder</span><br><span class="line">功能 --- String转换 </span><br><span class="line">注意：</span><br><span class="line">   Netty的编解码体系中 </span><br><span class="line"><span class="bullet">   1.</span> ByteToMessage</span><br><span class="line"><span class="code">      MessageToByte</span></span><br><span class="line"><span class="code">      </span></span><br><span class="line"><span class="code">      MessageToMessageDecoder</span></span><br><span class="line"><span class="code">      MessageToMessageEncoder</span></span><br><span class="line"><span class="code">      </span></span><br><span class="line"><span class="code">   2. 区别</span></span><br><span class="line"><span class="code">      1. Byte系列的编解码 更底层</span></span><br><span class="line"><span class="code">         decode方法参数 观察到的</span></span><br><span class="line"><span class="code">         </span></span><br><span class="line"><span class="code">      2. ByteToMessage体系 </span></span><br><span class="line"><span class="code">         解决封帧的问题 （半包 粘包）</span></span><br><span class="line"><span class="code">         </span></span><br><span class="line"><span class="code">         MessageToMessage不自己解决。</span></span><br><span class="line"><span class="code">         FixedLengthFrameDecoder</span></span><br><span class="line"><span class="code">         LineBasedFrameDecoder </span></span><br><span class="line"><span class="code">         LengthFieldBasedFrameDecoder</span></span><br><span class="line"><span class="code">         </span></span><br><span class="line"><span class="code">2. 封帧相关的</span></span><br><span class="line"><span class="code">   FixedLengthFrameDecoder</span></span><br><span class="line"><span class="code">   LineBasedFrameDecoder </span></span><br><span class="line"><span class="code">   LengthFieldBasedFrameDecoder</span></span><br><span class="line"><span class="code">   </span></span><br><span class="line"><span class="code">3. Java序列化相关的编解码</span></span><br><span class="line"><span class="code">    ObjectEncoder  </span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    ObjectDecoder()  LengthFieldBasedFrameDecoder子类 不会有半包粘包</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    编解码器 Netty。做了一定的优化，数据小 ---&gt; 幻术 </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> JSON相关的编解码器</span><br><span class="line">   Netty JSON编码器(String ---&gt; ) 只提供了JSON解码器 JsonObjectDecoder</span><br><span class="line">   针对于JSON数据 做封帧的（半包 粘包)</span><br><span class="line">   </span><br><span class="line"><span class="bullet">5.</span> Http协议编解码操作 </span><br><span class="line">   Netty支持对Http协议进行编解码 ---》 Netty可以作为Web服务器 ---》 SpringWebFlex 底层就是基于Netty. ---&gt;Gateway</span><br><span class="line">   </span><br><span class="line"><span class="bullet">   1.</span> HttpServerCodec()</span><br><span class="line"><span class="bullet">   2.</span> HttpObject子类进行编程了。</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="bullet">   1.</span> pipeline的调用与 Message的个事相关</span><br><span class="line"><span class="bullet">   2.</span> 可以通过SimpleChannelInboundHandler限定消息的类型</span><br><span class="line"><span class="bullet">   3.</span> channelRead0 和 channelRead区别是什么？</span><br><span class="line"><span class="code">      channelRead底层调用channelRead0</span></span><br><span class="line"><span class="code">      在channelRead中已经对于msg做了类型的转换。</span></span><br><span class="line"><span class="code">   4. HttpObjectAggregator</span></span><br><span class="line"><span class="code">      HttpRequest 和 HttpContent 聚合在一起。</span></span><br><span class="line"><span class="code">      </span></span><br><span class="line"><span class="code">   5. Http协议的解码器，会出现半包粘包问题么？</span></span><br><span class="line"><span class="code">      Http协议Content-Length ---&gt; 数据 不会出现。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zyzstart/picgodemo/img/image-20240413000201339.png" alt="image-20240413000201339"></p>
<h5 id="自定义编解码器"><a href="#自定义编解码器" class="headerlink" title="自定义编解码器"></a>自定义编解码器</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 编码器  </span><br><span class="line">   extends MessageToByteEncoder</span><br><span class="line">   encode</span><br><span class="line"> </span><br><span class="line"><span class="bullet">2.</span> 编码器</span><br><span class="line">   extends ByteToMessageDecoder</span><br><span class="line"><span class="bullet">   1.</span> 如果ByteBuf的数据一次解码没有处理完成，则Netty会重复调用decode方法</span><br><span class="line">   </span><br><span class="line"><span class="bullet">3.</span> extends ByteToMessageCodec</span><br><span class="line">   编解码器 合二为一</span><br><span class="line">   </span><br><span class="line"><span class="bullet">4.</span> Netty提供的一个特殊的解码器 ReplayingDecoder</span><br><span class="line">   他的实现类 中的decode方法 不需要做任何安全设置。</span><br><span class="line">   </span><br><span class="line">   Netty编程 </span><br><span class="line"><span class="bullet">     1.</span> Bytebuf读写指针 </span><br><span class="line"><span class="bullet">     2.</span> Bytebuf释放 </span><br></pre></td></tr></table></figure>

<h5 id="自定义系统的通信协议"><a href="#自定义系统的通信协议" class="headerlink" title="自定义系统的通信协议"></a>自定义系统的通信协议</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 设计协议   </span><br><span class="line">   client 与 服务器端 传输数据的格式 </span><br><span class="line">   协议头 </span><br><span class="line"><span class="code">      幻数（魔术）suns版本号 </span></span><br><span class="line"><span class="code">      指令类型  登录 注册 xxx 业务操作的编号</span></span><br><span class="line"><span class="code">      序列化的方式：1 json 2 protobuf 3 hession</span></span><br><span class="line"><span class="code">      正文长度</span></span><br><span class="line"><span class="code">   协议正文（协议体）消息正文 </span></span><br><span class="line"><span class="code">      &#123;name:&quot;sunshuai&quot;,password:&quot;xiaohei&quot;&#125;</span></span><br><span class="line"><span class="code">      </span></span><br><span class="line"><span class="code">2. 编解码</span></span><br><span class="line"><span class="code">    参看代码 </span></span><br></pre></td></tr></table></figure>

<h4 id="ChannelHandler总结"><a href="#ChannelHandler总结" class="headerlink" title="ChannelHandler总结"></a>ChannelHandler总结</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> Handler作用：</span><br><span class="line"><span class="bullet">   1.</span> 网络连接（Channel)已经建立，通过Handler IO相关的操作。 处理IO中的数据。ChannelHandler是Netty中最为重要的一个组件。与开发息息相关。</span><br><span class="line"> </span><br><span class="line"><span class="bullet">2.</span> Pipeline中Handler执行流程？</span><br><span class="line"><span class="bullet">   1.</span> Pipleine底层数据结构 双向列表 输入（入栈） 输出（出栈） </span><br><span class="line"><span class="bullet">   2.</span> Pipeline中</span><br><span class="line"><span class="code">       head ChannelInitializer  hander1 hander2 hander3..      tail</span></span><br><span class="line"><span class="code">       </span></span><br><span class="line"><span class="code">3. channel.writeAndFlush 与 ChannelHandlerContext.writeAndFlush()区别</span></span><br><span class="line"><span class="code">   1. channel.writeAndFlush 从整个pipeline的最后一个输出的handler(OutboundHandler)开始依次执行OutboundHandler</span></span><br><span class="line"><span class="code">   2. channelHandlerContext.writeAndFlush() 从当前位置依次查找前面的OutBoundHandler进行依次执行。</span></span><br><span class="line"><span class="code">   </span></span><br><span class="line"><span class="code">4. ByteBuf的使用和释放</span></span><br><span class="line"><span class="code">    //不建议使用 </span></span><br><span class="line"><span class="code">      ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer();</span></span><br><span class="line"><span class="code">    //建议</span></span><br><span class="line"><span class="code">      ctx.alloc().buffer();</span></span><br><span class="line"><span class="code">      </span></span><br><span class="line"><span class="code">      ByteBuf用完后一定 realase() </span></span><br><span class="line"><span class="code">      </span></span><br><span class="line"><span class="code"> 5. channel的生命周期方法 或者 ChannelHandler中回调</span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code">    SocketChannel IO操作  不负责accpet</span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code">    initchannel</span></span><br><span class="line"><span class="code">    0. addHandler </span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    1.channelRegistered  </span></span><br><span class="line"><span class="code">        当连接（Channel)被分配到了具体的worker线程上，回调这个方法。</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">        问题：有没有可能Channel被accept但是没有分配worker？</span></span><br><span class="line"><span class="code">        答 存在这个可能性，client并发多与worker的数量。</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">   2. channelActive 【常用】</span></span><br><span class="line"><span class="code">        channel的准备工作基本完成了。所有的pipeline上面的handler添加完成。 channel准备就绪了。</span></span><br><span class="line"><span class="code">        channelActive方法被回调用，就因为这个client和服务端 可以进行通信了。</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">        应用过程中，可以通过channelActive回调，像另一方写数据</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">   3.channelRead【常用】</span></span><br><span class="line"><span class="code">        接受数据操作，每一次发过来数据都会回调这个方法。</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">   4. channelReadComplete</span></span><br><span class="line"><span class="code">       读操作结束。目的 资源性的释放，类似于finally</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    下面的2个方法 ，都会在channel关闭的时候 调用</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    服务端调用close,则直接回调 后面的2个方法</span></span><br><span class="line"><span class="code">    客户端调用close方法，发送消息到服务端。</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">  5.channelInactive</span></span><br><span class="line"><span class="code">      channel连接断掉，TCP连接没有了</span></span><br><span class="line"><span class="code">      </span></span><br><span class="line"><span class="code">  6.channelUnregistered</span></span><br><span class="line"><span class="code">      对应分配给我们的worker线程 换回 EventLoopGroup </span></span><br><span class="line"><span class="code">      </span></span><br><span class="line"><span class="code">  7. removeHandler</span></span><br><span class="line"><span class="code">  </span></span><br><span class="line"><span class="code">  为什么了解回调 ---Channel相关一些事件 。Netty (基于事件的异步通信框架)</span></span><br><span class="line"><span class="code">  </span></span><br><span class="line"><span class="code">6. 异常的处理</span></span><br><span class="line"><span class="code">   exceptionCaught</span></span><br><span class="line"><span class="code">     如果本handler出现的异常 这个方法可以处理</span></span><br><span class="line"><span class="code">     如果本handler中前面handler出现的未处理异常，他也可以处理。</span></span><br><span class="line"><span class="code">   开发的过程中 一定要设置日志，没有日志，无法挑错。</span></span><br><span class="line"><span class="code">   </span></span><br><span class="line"><span class="code">  </span></span><br><span class="line"><span class="code">7. Handler相关内容</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zyzstart/picgodemo/img/image-20240413000217605.png" alt="image-20240413000217605"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zyzstart/picgodemo/img/image-20240413000229989.png" alt="image-20240413000229989"></p>
<h5 id="IdleStateHandler"><a href="#IdleStateHandler" class="headerlink" title="IdleStateHandler"></a>IdleStateHandler</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">作用：空闲检查 </span><br><span class="line"><span class="bullet">1.</span> 注意： 常用于服务端监控的一个Handler</span><br><span class="line"><span class="code">         读空闲 ，写空闲 ，读写空闲 （空闲指的就是没有通信）</span></span><br><span class="line"><span class="code">         </span></span><br><span class="line"><span class="code">开发场景： </span></span><br><span class="line"><span class="code">   心跳 :  在一段时间内 读写都空闲 更能说明，网络有可能不同。</span></span><br><span class="line"><span class="code">           读写空闲</span></span><br><span class="line"><span class="code">           </span></span><br><span class="line"><span class="code">           </span></span><br><span class="line"><span class="code">   注意： 1. 心跳检测是二种方式：</span></span><br><span class="line"><span class="code">            1. IdleStateHandler 方式 空闲时间 最够长 死了 一次性处理。</span></span><br><span class="line"><span class="code">            2. 一定的时间间隔 一定次数 死 </span></span><br><span class="line"><span class="code">   </span></span><br><span class="line"><span class="code">         2. 监控到了空闲之后，核心关闭channel。完成业务处理的善后工作。 </span></span><br><span class="line"><span class="code">         </span></span><br><span class="line"><span class="code">         3. 客户端角度：如果发现 channel关了，但是client本身没事，重试的机制。</span></span><br><span class="line"><span class="code">            定时任务。</span></span><br></pre></td></tr></table></figure>

<h5 id="WebSocketServerProtocalHandler"><a href="#WebSocketServerProtocalHandler" class="headerlink" title="WebSocketServerProtocalHandler"></a>WebSocketServerProtocalHandler</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 增加 Netty处理WebSocket能力..</span><br><span class="line"></span><br><span class="line">常规的问题 </span><br><span class="line"><span class="bullet">    1.</span> WebSocket干什么？</span><br><span class="line"><span class="code">    协议：全双工的</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    传统的Http1.0协议  短连接协议， 请求 《---》 响应 结束 连接（断了） 无状态协议 （用户会话追踪，cookie --&gt; session）</span></span><br><span class="line"><span class="code">    传统的Http1.1协议  有限的长连接 目的 减少tcp 连接 握手的次数 keepalive 决定连接的时长</span></span><br><span class="line"><span class="code">    HTTP 持久性连接（也称为HTTP keep-alive或HTTP 连接重复使用）是一种概念，允许单个TCP 连接发送和接收多个HTTP 请求/响应，而不是为每个请  求/响应对打开新连接。 Apigee 使用持久性连接与后端服务进行通信。 默认情况下，连接保持活动状态60 秒。</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    不能做推送 服务端 推数据</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    服务器端 发生变化了 主动告知 client</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    2. WebSocket协议 Http协议关系是什么？</span></span><br><span class="line"><span class="code">       WebSocket在Http协议之上的。</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    3. Netty如何支持WebScoket</span></span><br><span class="line"><span class="code">       WebSocketServerProtocalHandler </span></span><br></pre></td></tr></table></figure>

<h5 id="Shareable-可以共享的Handler"><a href="#Shareable-可以共享的Handler" class="headerlink" title="Shareable [可以共享的Handler]"></a>Shareable [可以共享的Handler]</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">多个Pipeline中共用Handler的方式 </span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 不要在pipeline中new Handler,把new Handler的过程提取到外面，这样多个Pipeline就可以共用Handler.</span><br><span class="line"><span class="bullet">2.</span> 如果共用Handler就意味着 Handler会被多线程访问。</span><br><span class="line"></span><br><span class="line">Handler处理过程中 什么情况下可以被多个pipeline共用 </span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 无状态的Handler 或者  有状态但是 加锁 Handler 可以被Pipeline共用。</span><br><span class="line"><span class="bullet">2.</span> MessageToMessasgeDcoder 也可共用。能被共用的Handler 会通过一个 注解生命 @Sharable.</span><br><span class="line"><span class="bullet">3.</span> ByteToMessageDecoder 及其子类  不能。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">   开发能被共用的@Sharable ,不能被共用的不加@Sharable(ByteToMessageDecoder)</span><br><span class="line">   能加的就提取出来共用，不能加的就Pipeline 去创建了。</span><br><span class="line">   </span><br><span class="line">开发建议：</span><br><span class="line">   自定义的过程中，Handler处理成无状态 （没有成员变量），可以使用Sharable。</span><br></pre></td></tr></table></figure>

<h5 id="规范化Netty的开发"><a href="#规范化Netty的开发" class="headerlink" title="规范化Netty的开发"></a>规范化Netty的开发</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.suns.netty14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">// channel 什么关闭？</span></span><br><span class="line"><span class="comment">// handler一些回调方法进行处理</span></span><br><span class="line"><span class="comment">// IdleStateHandler处理 关闭channel</span></span><br><span class="line"><span class="comment">// 异常发生 也会关闭channel</span></span><br><span class="line"><span class="comment">// 程序正常退出 。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写内容 都要在Handler中完成。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyNettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyNettyClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, JsonProcessingException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">eventLoopGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">loggingHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>();</span><br><span class="line">        <span class="type">StringEncoder</span> <span class="variable">stringEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEncoder</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">group</span> <span class="operator">=</span> bootstrap.group(eventLoopGroup);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="string">&quot;logging&quot;</span>, loggingHandler);</span><br><span class="line">                    ch.pipeline().addLast(<span class="string">&quot;stringEnoder&quot;</span>, stringEncoder);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ctx.writeAndFlush(<span class="string">&quot;xiaohei&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8000</span>)).sync().channel();</span><br><span class="line">            <span class="comment">//监控channel的关闭</span></span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.suns.netty14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyNettyServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyNettyServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">loggingHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//workerGroup默认 后续结合内存的压力进行调整。</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                    pipeline.addLast(loggingHandler);</span><br><span class="line">                    <span class="comment">//共用的独立的使用 ，不能共用的自己创建</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8000</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Netty相关的参数"><a href="#Netty相关的参数" class="headerlink" title="Netty相关的参数"></a>Netty相关的参数</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> netty参数的设置位置</span><br><span class="line"></span><br><span class="line">client</span><br><span class="line">  bootstrap.option()</span><br><span class="line"></span><br><span class="line">server</span><br><span class="line">  serverBootstrap.option();      //ServerScoketChannel</span><br><span class="line">  serverBootstrap.childOption()  //ScoketChannel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> netty中 </span><br><span class="line"></span><br><span class="line">ChannelOption（ChannelOption进行配置修改） --- ChannelConfig(核心配置) ---DefaltChannelConfig（核心配置的默认值）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ChannelOption.XXXX,对应内容</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> RCVBUF<span class="emphasis">_ALLOCATOR  SocketChannel  </span></span><br><span class="line"><span class="emphasis">作用：设置服务端 ByteBuf缓冲区大小,这个IO ByteBuf在netty设计中，只能是直接内存。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">默认值：</span></span><br><span class="line"><span class="emphasis">   最小64 初始值1024 最大65535</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">主动设置</span></span><br><span class="line"><span class="emphasis">  serverBootstrap.childOption(ChannelOption.RCVBUF_</span>ALLOCATOR, new AdaptiveRecvByteBufAllocator(16,16,16));</span><br><span class="line">  </span><br><span class="line"><span class="bullet">2.</span> SO<span class="emphasis">_RCVBUF &amp;  SO_</span>SNDBUF [了解即可]</span><br><span class="line"> <span class="emphasis">*SO_RCVBUF ServerSocketChannl  option() 接受Socket缓冲区的大小 。</span></span><br><span class="line"><span class="emphasis"> SO_SNDBUF SocketChannel       客户端 option()  服务端 childOption 发送Socket缓冲区的大小。</span></span><br><span class="line"><span class="emphasis"> </span></span><br><span class="line"><span class="emphasis"> 2点注意：</span></span><br><span class="line"><span class="emphasis">    1. 目前的开发中，操作系统都比较智能了。定义合理的发送Socket缓冲 接受Socket缓冲区的大小。</span></span><br><span class="line"><span class="emphasis">    2. SO开头的参数 都是和操作系统底层 TCP协议相关的参数。所以这些参数 1. 可以在netty中通过参数设置 2. 直接修改操作系统对应的文件</span></span><br><span class="line"><span class="emphasis">    </span></span><br><span class="line"><span class="emphasis">3. ALLOCATOR</span></span><br><span class="line"><span class="emphasis">SocketChannel childOption()</span></span><br><span class="line"><span class="emphasis">ByteBuf内存分配器 </span></span><br><span class="line"><span class="emphasis">   ctx.alloc()</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">设置方式</span></span><br><span class="line"><span class="emphasis">serverBootstrap.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">区别 </span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">4. TCP_NODELAY 默认情况下 就是不延迟 </span></span><br><span class="line"><span class="emphasis">SocketChannel </span></span><br><span class="line"><span class="emphasis">Nagle算法 ：  </span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">5. CONNECT_TIMEOUT_MILLIS</span></span><br><span class="line"><span class="emphasis">SocketChannel</span></span><br><span class="line"><span class="emphasis">客户端在建立连接时，如果超过了参数指定的时间，抛出超时异常。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zyzstart/picgodemo/img/image-20240413000312783.png" alt="image-20240413000312783"></p>
 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*6. SO_BACKLOG</span></span><br><span class="line"><span class="emphasis">ServerScoketChannel参数   .option()</span></span><br><span class="line"><span class="emphasis">含义：</span></span><br><span class="line"><span class="emphasis">  SO_BACKLOG 决定了3次握手之后，全连接队列的大小。</span></span><br><span class="line"><span class="emphasis">  系统层面  /proc/sys/net/core/somaxconn 在这个文件中设置 </span></span><br><span class="line"><span class="emphasis">  Netty运行过程中 全连接队列的大小 ，min(SO_BACKLOG,somaxconn)</span></span><br><span class="line"><span class="emphasis">  </span></span><br><span class="line"><span class="emphasis">  补充注意：半连接队列 没有最大值 无限大 可以不用考虑 </span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">tcp建立连接3次握手</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>7. SO<span class="emphasis">_REUSEADDR </span></span><br><span class="line"><span class="emphasis">ServerScoketChannel参数   .option()</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">端口复用：可以使用别的进程使用的端口 </span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">为什么需要这个方式：Server非正常关闭，或者正常关闭过程中出现意外，都有可能导致端口被占用，后续需要重新启动服务时，就会出现端口被占用异常。</span></span><br><span class="line"><span class="emphasis">                 为了解决这个问题，需要端口复用</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">tcp关闭连接4次握手</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">8. SO_</span>KeepAlive</span><br><span class="line"><span class="bullet">1.</span> 目前的开发中 没有必要使用TCP keepalive 。还是需要心跳解决 活跃的问题。</span><br><span class="line">   KeepAlive  TCP协议：7200  9 75秒 一次</span><br><span class="line"></span><br><span class="line">   net.ipv4.tcp<span class="emphasis">_keeplive_</span>time = 7200</span><br><span class="line">   net.ipv4.tcp<span class="emphasis">_keeplive_</span>xxx</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 心跳站在应用层的角度解决问题</span><br><span class="line">   KeepAlive站在TCP层次解决问题。</span><br><span class="line">   </span><br><span class="line"><span class="bullet">3.</span> Http协议1.1，保证 有限长连接 KeepAlive头 60秒</span><br><span class="line">   TCP协议中KeepAlive 是什么关系呢？</span><br><span class="line">   </span><br><span class="line">   半毛钱的关系都没有。</span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Michael</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/10/17/Netty2/">http://example.com/2023/10/17/Netty2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Michael的小木屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="http:///p2.qhimg.com/t010ad2c94c7a13a383.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/24/kafka/"><img class="prev-cover" src="http:///p3.qhimg.com/t01e2fa62f505895db7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kafka</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/17/Netty1/"><img class="next-cover" src="http:///p9.qhimg.com/t0163fa31dd6351bf12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty（上）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Michael</div><div class="author-info__description">后端学徒，记录学习</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zyzstart" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1738091590@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91"><span class="toc-number">1.</span> <span class="toc-text">Netty应用开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">1. 引言</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AFNetty"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 什么是Netty</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8Netty"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2为什么需要使用Netty</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-Netty%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 Netty的发展历程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-%E8%B0%81%E5%9C%A8%E7%94%A8Netty"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 谁在用Netty</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">Netty的第一个应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 环境搭建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-NIO"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 第一个程序分析 [NIO]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EventLoop"><span class="toc-number">1.2.3.</span> <span class="toc-text">EventLoop</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EventLoopGroup"><span class="toc-number">1.2.4.</span> <span class="toc-text">EventLoopGroup</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NioEventLoop%E5%92%8CDefaultEventLoop%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.5.</span> <span class="toc-text">NioEventLoop和DefaultEventLoop区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-number">1.2.6.</span> <span class="toc-text">注意：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">1.2.7.</span> <span class="toc-text">异步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Netty%E4%B8%AD%E5%BC%82%E6%AD%A5%E8%AE%BE%E8%AE%A1-%EF%BC%88%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%EF%BC%89"><span class="toc-number">1.2.8.</span> <span class="toc-text">Netty中异步设计 （内部原理）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Channel"><span class="toc-number">1.2.9.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Handler-%E9%87%8D%E8%A6%81-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B"><span class="toc-number">1.2.10.</span> <span class="toc-text">Handler[重要 程序员编程]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ByteBuf"><span class="toc-number">1.2.11.</span> <span class="toc-text">ByteBuf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ByteBuf%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.12.</span> <span class="toc-text">ByteBuf的基础使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ByteBuf%E4%B8%8E%E5%86%85%E5%AD%98%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.13.</span> <span class="toc-text">ByteBuf与内存关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ByteBuf%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.14.</span> <span class="toc-text">ByteBuf内存结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ByteBuf%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE"><span class="toc-number">1.2.15.</span> <span class="toc-text">ByteBuf内存释放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#API"><span class="toc-number">1.2.16.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8A%E5%8C%85%E7%B2%98%E5%8C%85-%EF%BC%88%E9%BB%8F%E5%8C%85%EF%BC%89"><span class="toc-number">1.2.17.</span> <span class="toc-text">半包粘包 （黏包）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Netty%E5%8D%8A%E5%8C%85%E7%B2%98%E5%8C%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F-%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.2.18.</span> <span class="toc-text">Netty半包粘包的解决方式 思路分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8-%EF%BC%88Codec%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">编解码器 （Codec）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E8%A7%A3%E7%A0%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 什么是编解码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Netty%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">Netty常见的编解码器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">自定义编解码器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.3.4.</span> <span class="toc-text">自定义系统的通信协议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelHandler%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">ChannelHandler总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IdleStateHandler"><span class="toc-number">1.4.1.</span> <span class="toc-text">IdleStateHandler</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WebSocketServerProtocalHandler"><span class="toc-number">1.4.2.</span> <span class="toc-text">WebSocketServerProtocalHandler</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Shareable-%E5%8F%AF%E4%BB%A5%E5%85%B1%E4%BA%AB%E7%9A%84Handler"><span class="toc-number">1.4.3.</span> <span class="toc-text">Shareable [可以共享的Handler]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E5%8C%96Netty%E7%9A%84%E5%BC%80%E5%8F%91"><span class="toc-number">1.4.4.</span> <span class="toc-text">规范化Netty的开发</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">Netty相关的参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.5.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/20/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="DDIA阅读"><img src="http:///p0.qhimg.com/t015815bdb897cdb6ce.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DDIA阅读"/></a><div class="content"><a class="title" href="/2024/04/20/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="DDIA阅读">DDIA阅读</a><time datetime="2024-04-19T16:00:00.000Z" title="发表于 2024-04-20 00:00:00">2024-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/20/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="凤凰架构读书笔记"><img src="http:///p4.qhimg.com/t0196dfad56317fe205.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="凤凰架构读书笔记"/></a><div class="content"><a class="title" href="/2024/04/20/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="凤凰架构读书笔记">凤凰架构读书笔记</a><time datetime="2024-04-19T16:00:00.000Z" title="发表于 2024-04-20 00:00:00">2024-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/24/kafka/" title="Kafka"><img src="http:///p3.qhimg.com/t01e2fa62f505895db7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kafka"/></a><div class="content"><a class="title" href="/2023/11/24/kafka/" title="Kafka">Kafka</a><time datetime="2023-11-23T16:00:00.000Z" title="发表于 2023-11-24 00:00:00">2023-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/17/Netty2/" title="Netty（下）"><img src="http:///p2.qhimg.com/t010ad2c94c7a13a383.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty（下）"/></a><div class="content"><a class="title" href="/2023/10/17/Netty2/" title="Netty（下）">Netty（下）</a><time datetime="2023-10-16T16:00:00.000Z" title="发表于 2023-10-17 00:00:00">2023-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/17/Netty1/" title="Netty（上）"><img src="http:///p9.qhimg.com/t0163fa31dd6351bf12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty（上）"/></a><div class="content"><a class="title" href="/2023/10/17/Netty1/" title="Netty（上）">Netty（上）</a><time datetime="2023-10-16T16:00:00.000Z" title="发表于 2023-10-17 00:00:00">2023-10-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('http:///p2.qhimg.com/t010ad2c94c7a13a383.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By Michael</div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>